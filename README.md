За основу взят create-react-app.  
Старт приложения:
```bash
yarn install
yarn start
```
Т.к. в условиях тестового задания прямо сказано, что лучше написать заглушку на фронтенде, так и было сделано. Используется мок WebSocket-сервера, все обращения к нему логируются в консоли браузера.


Flow
====
Для проверки аннотаций типов можно использовать команды:
```bash
yarn flow
yarn glow
```
Во второй команде используется сторонний форматтер ошибок.


Виртуальный скроллинг
=====================
Для боевого приложения лучше взять `react-virtualized`, но т.к. этот вопрос близок к теме тестового задания, решил сделать виртуальный скроллинг сам.


Создам два дива: внешнюю обёртку и внутренний контейнер элементов (.List-wrap и .List-container).
Т.к. все загруженные элементы известны, я могу просто вычислить и установить высоту контейнера
(добавив overflow-y: scroll для враппера). Это даст для отдельного компонента прокручиваемый див,
который при необходимости можно растянуть на весь вьюпорт.
Теперь подписываюсь на изменения размера враппера и на прокрутку контейнера внутри враппера,
в результате получаю все необходимые данные, чтобы вычислить видимые в текущий момент элементы списка.
Соответственно рендерю только их.

Узкое место: детектор ресайза враппера. Для этого есть много подходов и вариантов,
начиная от setInterval с постоянным вычислением размеров и от IE-специфичных апи
до глобального события resize (с обработкой нужного элемента внутри коллбека) или просто jquery.
Я использовал новый ResizeObserver, на момент написания ТЗ он был без флага доступен только в Chrome 64
(только для десктопа, в Chrome 64 for Android по-прежнему под флагом),
под флагом начиная с Chrome Canary 55 согласно блогу Google и с 54 согласно [caniuse](https://caniuse.com/resizeobserver).
Для поддержки остальных браузеров использовал полифил
[resize-observer-polyfill](https://www.npmjs.com/package/resize-observer-polyfill).
Перед внедрением в production-код конечно же надо потратить отдельное время
на изучение работы полифила в браузерах, которые используются аудиторией продукта.


Точки улучшения
===============



Описание тестового задания:
===========================

Реализовать список собеседников в чате. В списке неограниченное кол-во пользователей.
Референс: https://vk.com/im , https://web.telegram.org/#/im

Элемент списка должен содержать:
1. Имя пользователя
2. Текст последнего сообщения
3. Дата последнего сообщения
4. Кол-во непрочитанных сообщений

Сортировка списка по дате последнего сообщения.
По клику на пользователя все сообщения необходимо отметить как прочитанные.

При открытии страницы должны быть отображены тестовые данные: 1000 пользователей.
На той же странице добавить нескольких тестовых кнопок, которые инициируют события с сервера:
1. Новое сообщение от пользователя, которого еще нет в списке
2. Новое сообщение от одного из последних 10 собеседников
3. Новое сообщение от случайного пользователя

В тестовом задании будет оцениваться:
1. Скорость и корректность работы интерфейса: пользователи не должны теряться или дублироваться
2. Взаимодействие с бэкендом: корректность API, кол-во запросов

Реализация бэкенда не будет оценена.
Лучше всего написать небольшую заглушку на фронтенде с возможностью просмотра запросов в консоли.
