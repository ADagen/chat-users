За основу взят create-react-app.


======================================


Лист.жс: подписаться на скролл в пассив режиме
Сделать пулл переиспользуемых дивов с абсолютным позиционированием
Про переиспользуемость погорячился
При скроллировании ставить новый оффсет в пропсы
Высота элемента фиксированная, задана константой
По оффсету и высоте одного элемента вычислять, какие юзеры сейчас видны
(с запасом сверху-снизу, рендерить только этих юзеров)
Ставить им абс позицию
Общую высоту внутреннего блока тоже ставить, на изменение кол-ва юзеров
Для хранения списка юзеров в сторе использовать https://github.com/funkia/list/


Тип данных списка пользователей
===============================
Так как некоторые операции с массивами довольно тяжёлые (напр. создаётся лишний массив),
то для оптимальной работы требуется другой тип данных. Я посчитал, что ручная имплементация
более подходящего типа данных слишком далека от темы тестового задания и взял готовую реализацию (List использует сжатое префиксное дерево).

Виртуальный скроллинг
=====================
Создам два дива: внешнюю обёртку и внутренний контейнер элементов (.List-wrap и .List-container).
Т.к. все загруженные элементы известны, я могу просто вычислить и установить высоту контейнера
(добавив overflow-y: scroll для враппера). Это даст для отдельного компонента прокручиваемый див,
который при необходимости можно растянуть на весь вьюпорт.
Теперь подписываюсь на изменения размера враппера и на прокрутку контейнера внутри враппера,
в результате получаю все необходимые данные, чтобы вычислить видимые в текущий момент элементы списка.
Соответственно рендерю только их.

Узкое место: детектор ресайза враппера. Для этого есть много подходов и вариантов,
начиная от setInterval с постоянным вычислением размеров и от IE-специфичных апи
до глобального события resize (с обработкой нужного элемента внутри коллбека) или просто jquery.
Я использовал новый ResizeObserver, на момент написания ТЗ он был без флага доступен только в Chrome 64
(только для десктопа, в Chrome 64 for Android по-прежнему под флагом),
под флагом начиная с Chrome Canary 55 согласно блогу Google и с 54 согласно [caniuse](https://caniuse.com/resizeobserver).
Для поддержки остальных браузеров использовал полифил
[resize-observer-polyfill](https://www.npmjs.com/package/resize-observer-polyfill).
Перед внедрением в production-код конечно же надо потратить отдельное время
на изучение работы полифила в браузерах, которые используются аудиторией продукта.



Описание тестового задания:
===========================

Реализовать список собеседников в чате. В списке неограниченное кол-во пользователей.
Референс: https://vk.com/im , https://web.telegram.org/#/im

Элемент списка должен содержать:
1. Имя пользователя
2. Текст последнего сообщения
3. Дата последнего сообщения
4. Кол-во непрочитанных сообщений

Сортировка списка по дате последнего сообщения. По клику на пользователя все сообщения необходимо отметить как прочитанные.

При открытии страницы должны быть отображены тестовые данные: 1000 пользователей. На той же странице добавить нескольких тестовых кнопок, которые инициируют события с сервера:
1. Новое сообщение от пользователя, которого еще нет в списке
2. Новое сообщение от одного из последних 10 собеседников
3. Новое сообщение от случайного пользователя

В тестовом задании будет оцениваться:
1. Скорость и корректность работы интерфейса: пользователи не должны теряться или дублироваться
2. Взаимодействие с бэкендом: корректность API, кол-во запросов

Реализация бэкенда не будет оценена. Лучше всего написать небольшую заглушку на фронтенде с возможностью просмотра запросов в консоли.
